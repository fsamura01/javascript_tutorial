# Common Algorithm Design Approaches/

- Divide and Conquer: This is a top-down approach that resolves complex problems by  
   dividing them into smaller subproblems, solving each subproblem, and combining the  
   solutions to create a solution to the original problem. Examples include QuickSort,  
   MergeSort, and the Strassen's Matrix Multiplication algorithm.

- Greedy: This approach makes the locally optimal choice at each stage with the hope  
  of finding a global optimum. It doesn't necessarily find the best solution, but it
  often produces a satisfactory solution in a reasonable amount of time.

- Dynamic Programming: This method solves complex problems by breaking them down  
  into simpler subproblems.Each subproblem is solved only once, and the solutions  
  to these subproblems are stored in a table, which speeds up the process of solving complex problems.

- Backtracking: This approach is used to solve problems where the solutions  
  are the sequences of decisions. It builds candidate solutions incrementally,  
  one piece at a time. If at any point, the extended candidate solution cannot possibly be  
  extended to a valid solution, the search continues with the next candidate.

- Brute Force: This is the simplest approach, in which all possible solutions are explored untill  
  the desired results are found. It's not always practical for larger problem sets due to its computational complexity.

- Sorting: This is a fundamental algorithmic problem, and several efficient  
  sorting algorithms have been developed, such as QuickSort, MergeSort, and HeapSort.

- Recursion: Some problems can be solved by breaking them down into smaller,
  simplified versions of the same problem. Recursion is a way to implement  
  this kind of problem-solving approach.

- Randomized Algorithms: These algorithms use random numbers to make decisions  
  and can often solve problems more efficiently than deterministic algorithms,  
  especially in specific applications[9].

- Binary Search: This method is an efficient algorithm for  
  finding an item from a sorted list by repeatedly  
  dividing the search interval in half[10].
